create directory in bash
cd ~                          # change directories to your home directory
mkdir version-control         # make version-control directory
cd version-control            # go to version-control directory
mkdir reflections             # create reflections directory
cd reflections                # go to reflections directory
subl lesson_1_reflections.txt # launch sublime with file called lesson_1_reflections.txt (you can replace subl with another editor here if you prefer a different one)
git mv smth.html reflection   # move html into reflection directory\
								is == mv smth.html reflection 
								git add lib/smth.html
								git rm smth.html
touch name.type               # create .type

start filename                # open the file, it can be html
git config ­­global user.name # "Your name"
git config ­­global user.email# "youremail@domain.com".
		If you want to keep the changes, you can commit them, but first you’ll need to let git know your
		name and email address by entering the commands git config ­­global user.name
		"Your name"and git config ­­global user.email "youremail@domain.com".
		Then you can commit your changes using git commit ­a ­m "Commit message"where
		the commit message can be anything you want. The ­a flag means to commit all the changes
		you’ve made. You’ll see in Lesson 2 how to choose what to commit.
git log                  # fatal: bad default revision 'HEAD' means no commit yet
ls -a                         # show all the hidden files
git status                    # show what files have changed since last commit
git checkout
git checkout master           # go back to master
git diff id1 id2              # compare two commits in repository enter their IDs
git diff                      # no arguments for compare with the staging area and the working repository, after git add filename of all files, then it 								will show no difference, if no output then shows no change anymore
git diff --staged             # to compare staging area and repository, if no output then means no change anymore
git reset --hard              # mean discard all changes in staging area and working directory, be careful, because then those changes are gone and cant
							  # get back
git clone url                 # clone url
git init                      # create repository which is .git
git add                       # add to staging area
git commit                    # commit to repository
git branch                    # no argument show the current branch, we get *master
git branch easy-mode          # create a new branch with the name easy-mode, then run git branch, we
								have easy-mode and *master, * means the current checkout
								we can run git checkout easy-mode, in order to make change to easy-mode
git checkout -b newbranchname # == git branch newbranchname + git checkout newbranchname
								to retain the new branch that we create, use this commit
git merge master brancename   # merge master with another branch
								(git merge) will also include the currently checked-out branch in the merged version. So if you have branch1 checked out, and you run git merge branch2 branch3, the merged version will combine branch1 as well as branch2 and branch3.  That’s because the branch1 label will update after you make the merge commit, so it’s unlikely that you didn’t want the changes from branch1 included in the merge. For this reason, you should always checkout one of the two branches you’re planning on merging before doing the merge. Which one you should check out depends on which branch label you want to point to the new commit.
								Since the checked-out branch is always included in the merge, you may have guessed that when you are merging two branches, you don't need to specify both of them as arguments to git merge on the command line. If you want to merge branch2 into branch1, you can simply (git checkout branch1) and then type (git merge branch2). 
								The only reason to type (git merge branch1 branch2) is if it helps you keep better mental track of which branches you are merging. 
								Also, since the two branches are merged, the order in which they are typed into the command line does not matter. [The key is to remember that git merge always merges all the specified branches into the currently checked out branch,] creating a new commit for that branch.
git show commitID             # show difference between a commnit and its parent, if we dont know who is the parent
git branch -d branchname      # -d: delete, delete the branch coins, it is ok after merge, because now master has already access to the branch, now 									delete the coin branch will only delete the label, 
git merge --abort             # Restore your files to their state before you started the merge by running
								Merge conflict

									If you get a message like this
										Auto-merging game.js
										CONFLICT (content): Merge conflict in game.js
											Automatic merge failed; fix conflicts and then commit the result.
											[then your files were not in the same state as Caroline's when you started the merge]. To fix this, complete the following steps:
										Restore your files to their state before you started the merge by running (git merge --abort)
										Double check the state of your files. If you run (git log) while the master branch is checked out, you should see Caroline's "Add color" commit as the second-most-recent, and the most recent should be your commit fixing the bullet bug. If you use git diff to compare your commit to Caroline's, your commit should introduce the line this.delayBeforeBullet = 10; on line 424. The line should be indented to the same level as the line below it using only spaces (no tabs), and the line should have no spaces after it.
										Once your file is in the correct state, create a new commit with your changes.
										Try the merge again.

										Merge conflict (Newline characters between Windows and Unix systems)
											Context: Whenever we hit the "Enter" key on the keyboard, we are actually telling the computer to insert an invisible character into our text file to indicate to the computer that there should be a new line. Unix systems adds one character called the "line feed" character or LF or \n while Windows systems adds two characters, "carriage return" and "line feed" or CRLF or \r\n.

											Caroline's files have LF because her files were edited on Mac OSX, which uses LF. If a Windows user were to edit Caroline's files, the Windows text editor might convert all LF to CRLF to make editing files possible. When the Windows user merges her file with Caroline's files, a merge conflict will result due to the different LF and CRLF characters.

											To fix this, Windows users should set the global autocrlf attribute to true: (git config --global core.autocrlf true). More information can be found here: https://help.github.com/articles/dealing-with-line-endings/#platform-all
git log --graph --oneline             # show commit history
git log -n1                           # show number of one commit in the past
git remote add name urlOnGitHub       # add remote to git
git remote                            # list the remote
git remote -v                         # list more details v: verbose
                                      # step: git init + git add name + git commit + git remote add origin https://github.com/shu-ti/reflections.git
                                        + git push (-u) origin master + enter user and pw

---question-----------------------------
How did viewing a diff between two versions of a file help you see the bug that
was introduced?

    diff uses + and - to diff the previous and the current, it is easy to view

How could having easy access to the entire history of a file make you a more
efficient programmer in the long term?

    if i made a typo or other mistakes or i dont like the new change i can always undo and go back on any version of my code

What do you think are the pros and cons of manually choosing when to create a
commit, like you do in Git, vs having versions automatically saved, like Google
docs does?

    pros: we can control the size of versions we have, so it wont saved unecessary version
    cons: we may forget to save at the end, or accident happen that could allow us to save

Why do you think some version control systems, like Git, allow saving multiple
files in one commit, while others, like Google Docs, treat each file separately?
	
	git allows us to changes multiple file and commit all them togethe, this is because sometimes our code are in different files
	it require all the file all ready and correct in order to let the code run without error,
	google docs will only add one file at a time, no need to interact with other files in order to use, so it saves files seperately

How can you use the commands git log and git diff to view the history of files?

    git log lists all the changes, authors and time that made in the past
    git diff allows you to compare the differences between two commits.

How might using version control make you more confident to make changes that
could break something?

    i can always go back to compare and check, all the version will be saved with notes

Now that you have your workspace set up, what do you want to try using Git for?

    share files 

---------------------------------------







definition:--------------------------
a commit is a snapshot of every file in the repository at the same time the commit was made
a git repository is the collection of files that are tracked by git as a cohesive unit
--------------------



Sublime, or if Sublime is installed in another location for you. See this page for the correct command for a couple of other popular text editors. For any other editor, you'll need to enter the command you use to launch that editor from Git Bash.
git config --global core.editor "'C:/Program Files/Sublime Text 2/sublime_text.exe' -n -w"
git config --global push.default upstream
git config --global merge.conflictstyle diff3


Make sure you can start your editor from Git Bash
If you use Sublime, you can do this by adding the following line to your .bash_profile:
alias subl="C:/Program\ Files/Sublime\ Text\ 2/sublime_text.exe"
Restart Git Bash

You'll need to close and re-open Git Bash before all your changes take effect.





Git command review:-----------------------------
1. 
Compare two commits, printing each line that is present in one commit but not the other.
git diff will do this. It takes two arguments - the two commit ids to compare. 

Make a copy of an entire Git repository, including the history, onto your own computer.
git clone will do this. It takes one argument - the url of the repository to copy. 

Temporarily reset all files in a directory to their state at the time of a specific commit.
git checkout will do this. It takes one argument - the commit ID to restore. 

Show the commits made in this repository, starting with the most recent.
git log will do this. It doesn't take any arguments.


2.
Behavior of git clone

If someone else gives you the location of their directory or repository, you can copy or clone it to your own computer.
This is true for both copying a directory and cloning a repository.
As you saw in the previous lesson, if you have a URL to a repository, you can copy it to your computer using git clone.
For copying a directory, you weren't expected to know this, but it is possible to copy a directory from one computer to another using the command scp, which stands for "secure copy". The name was chosen because the scp command lets you securely copy a directory from one computer to another. 

The history of changes to the directory or repository is copied.
This is true for cloning a repository, but not for copying a directory. The main reason to use git clone rather than copying the directory is because git clone will also copy the commit history of the repository. However, copying can be done on any directory, whereas git clone only works on a Git repository. 

If you make changes to the copied directory or cloned repository, the original will not change.
This is true for both copying a directory and cloning a repository. In both cases, you're making a copy that you can alter without changing the original. 

The state of every file in the directory or repository is copied.
This is true for both copying a directory and cloning a repository. In both cases, all the files are copied.


3. 
Behavior of git checkout

Checking out an earlier commit will change the state of at least one file.
This is sometimes true. Git doesn't allow you to save a new commit if no files have been updated, so you might think this is always true. However, it's possible to do the following:
Save a commit (call this commit 1).
Update some files and save another commit (call this commit 2).
Change all the files back to their state during commit 1, then save again (call this commit 3).
This sometimes happens if commit 2 contained a bug, and it's important to fix the bug quickly. The easiest thing to do might be to remove all the changes introduced by commit 2 to fix the bug, then figure out how to safely reintroduce the changes later.
At this point, commit 3 is the latest commit, so if you checkout commit 1, none of the files will be changed. 

Checking out an earlier commit will change the state of more than one file.

Checking out an earlier commit will change the state of every file in the repository.
Both of these are sometimes true. Since each commit tracks the state of all files in the repository, it is possible that checking out an earlier commit will change the state of multiple files, or even all the files in the repository. However, it is possible to save a new commit after changing only one file, so it is possible only one file will change. 

After checking out a commit, the state of all the files in the repository will be from the same point in time.
This is always true. A commit saves a snapshot of all files in the repository at the time the commit was made, so checking out an earlier commit will result in all the files being reverted to their state at the time the commit was made. That is, the files will be in a consistent state.


4. 
Git repositories and directories
Each Git repository is tied to a specific directory - the directory where you ran git init. Only files from that directory (and subdirectories inside that directory) will be contained in that repository, and you can have different repositories in different directories.
Note: it's often the case that a Git repository in some directory will only contain, or track, some of the files in that directory, rather than all of them. You'll see how this works later this lesson.
run (git init): create .git
----------------------------------------------------
